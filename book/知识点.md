# map

第二个参数为this指向，第一个参数fn包含三个参数（当前值，索引，原数组）

# hasOwnProperty

可以用来检测一个对象是否含有特定的自身属性；和 [`in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。

> 如果数组中的元素为undefined，可以用hasOwnProperty检测出来，为undefined返回值是false

```js
// map实现
function selfMap(fn, thisArg){
    let attr = this.slice(),
        outArr = Array(attr.length);
    for(let i = 0; i < attr.length; i++){
        if(attr.hasOwnProperty(i)){ // 稀疏数组检测，检测key
            outArr[i] = fn.call(thisArg, attr[i], i, this);
        }
    }
    
    return outArr;
}

// some
function some(fn, thisArg){
    let attr = this.slice();
    for(let i = 0; i < attr.length; i++){
        if(attr.hasOwnProperty(i)){ // 稀疏数组检测，检测key
            if(fn.call(thisArg, attr[i], i, this)){
                return true;
            }
        }
    }
    return false;
}
// 执行 some 方法的数组如果是一个空数组，最终始终会返回 false， every 方法会始终返回 true

// reduce
function reduce(fn, initVal){
    let attr = this.slice();
    let startIndex,
        res;
    if(initVal === undefined){
        for(let i = 0; i < attr.length; i++){
            if(attr.hasOwnProperty(i)){
				startIndex = i;
                res = attr[i];
                break;
            }
        }
    }else{
        res = initVal;
        startIndex = -1;
    }
    
    if(res !== undefined){
		for(let i = ++startIndex; i < attr.length; i++){
            if(attr.hasOwnProperty(i)){
				res = fn.call(null, res, attr[i], i, this);
            }
        }
    }
    return res;
}
// 
```

# 菲波那切数列及其优化

```js
function fibonacci(n){
    if(n < 1) return 0;
    if(n === 1 || n === 2){
        return 1;
	}
    return fibonacci(n-1) + fibonacci(n-2);
}

function cached(fn){
    let cache = {};
    return n => cache[n] || (cache[n] = fn(n));
}

fibonacci = cached(fibonacci);
```

# 柯里化Curring

```js
// 直接返回值
function curring(fn, ...args){
    if(fn.length === args.length){
        return fn(...args);
    }
    return function(...args1){
		return curring(fn, ...args, ...args1);
    }
}
// 直接返回fn
function curring(fn){
    if(fn.length <=1){
		return fn;
    }
	function generator(...args){
        if(args.length === fn.length){
            return fn(...args);
        }
        return args1 => {
            return generator(...args, ...args1);
        }
    }
    return generator;
}
```

## 使用场景

### 参数复用

```js
function curring(fn, type){
	return function(){
        return fn(...args, type);
    }
}

function isArray = curring(function(obj, type){
    return Object.prototype.call(obj) === `[object ${type}]`;
}, 'Array')
```

# Object

`Object` 构造函数为给定值创建一个对象包装器。如果给定值是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。

当以非构造函数形式被调用时，`Object` 等同于 `new Object()`。

```js
new Object(null) // {}
new Object(undefined) // {}

let s = {};
new Object(s) === Object(s) // true
Object(s) === s // true

```

### Object.keys()

返回一个包含所有给定对象**自身**可枚举属性名称的数组。

### Object.getOwnPropertyNames()

返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。

```js
var a = {a: 1}
Object.defineProperty(a, 'b', {
	value: 'b',
	enumerable: false
})
var b = Object.create(a)
b.c = 'c'

Object.keys(a) // ['a']
Object.getOwnPropertyNames(a) // ['a', 'b']
Object.keys(b) // ['c']
Object.getOwnPropertyNames(b) // ['c']
```

# BFC

BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。

**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。

### 触发 BFC

只要元素满足下面任一条件即可触发 BFC 特性：

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

### BFC 特性及应用

- 同一个 BFC 下元素外边距会发生折叠，分属于不同的BFC时可以阻止margin重叠
- BFC 可以包含浮动的元素（清除浮动）
- BFC 可以阻止元素被浮动元素覆盖
- 计算BFC的高度时，浮动元素也参与计算

# Event Loop

所有任务可以分成两种，一种是**同步任务（synchronous）**，另一种是**异步任务（asynchronous）**。同步任务指的是，在**主线程**上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"**任务队列**"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

## 宏任务macrotask

**macrotask也叫tasks。** 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：

- setTimeout
- setInterval
- setImmediate (Node独有)
- requestAnimationFrame (浏览器独有)
- I/O

## 微任务

**microtask，也叫jobs。** 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：

- process.nextTick (Node独有)
- Promise
- Object.observe
- MutationObserver

![img](https://user-gold-cdn.xitu.io/2019/7/6/16bc6bd331a2116a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**具体步骤如下：**

1. 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；
2. 全局Script代码执行完毕后，调用栈Stack会清空；
3. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；
4. 继续取出为队列中位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。**注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行**；
5. microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；
6. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 重复第3-7个步骤；

**注意：**

> 1. 宏队列macrotask一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；
> 2. 微任务队列中所有的任务都会被依次取出来执行，直到microtask queue为空；
> 3. 在执行微队列microtask queue中任务的时候，如果又产生了microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到microtask queue为空停止。
> 4. UI rendering，它的节点是在执行完所有的microtask之后，下一个macrotask之前，紧跟着执行UI render。

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

# new原理

当在函数前面被加入 `new` 调用时，也就是构造器调用时，下面这些事情会自动完成：

1. 一个全新的对象会凭空创建（就是被构建）
2. *这个新构建的对象会被接入原形链（[[Prototype]]-linked）*
3. 这个新构建的对象被设置为函数调用的 `this` 绑定
4. 除非函数返回一个它自己的其他 **对象**，否则这个被 `new` 调用的函数将 *自动* 返回这个新构建的对象。

```js
function myNew() {
    let obj = {},
        Constructor = Array.prototype.shift.call(arguments);

    obj.__proto__ = Constructor.prototype;
    let res = Constructor.apply(obj, arguments);
    return typeof res === 'object' ? res : obj;
}
```

# JS 异步解决方案的发展历程以及优缺点

## 1. 回调函数（callback）

```js
setTimeout(() => {
    // callback 函数体
}, 1000)
```

**缺点：回调地狱，不能用 try catch 捕获错误，不能 return**

回调地狱的根本问题在于：

- 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符
- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（**控制反转**）
- 嵌套函数过多的多话，很难处理错误

```js
ajax('XXX1', () => {
    // callback 函数体
    ajax('XXX2', () => {
        // callback 函数体
        ajax('XXX3', () => {
            // callback 函数体
        })
    })
})
```

**优点：解决了同步的问题**（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）

## 2. Promise

Promise就是为了解决callback的问题而产生的。

Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装

**优点：解决了回调地狱的问题**

```js
ajax('XXX1')
  .then(res => {
      // 操作逻辑
      return ajax('XXX2')
  }).then(res => {
      // 操作逻辑
      return ajax('XXX3')
  }).then(res => {
      // 操作逻辑
  })
```

**缺点：无法取消 Promise ，错误需要通过回调函数来捕获**

to do by xc 取消Promise

## 3. Generator

**特点：可以控制函数的执行**，可以配合 co 函数库使用

```js
function *fetch() {
    yield ajax('XXX1', () => {})
    yield ajax('XXX2', () => {})
    yield ajax('XXX3', () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

## 4. Async/await

async、await 是异步的终极解决方案

**优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题**

**缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。**

```js
async function test() {
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch('XXX1')
  await fetch('XXX2')
  await fetch('XXX3')
}
```

下面来看一个使用 `await` 的例子：

```js
let a = 0
let b = async () => {
  a = a + await 10; // await返回10，让出线程，a = a + 10异步执行
  console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1

let a = 0
let b = async () => {
  a = (a = 2) + await 10; 
  console.log('2', a) // -> '2' 12
}
b()
a++
console.log('1', a) // -> '1' 3
```

对于以上代码你可能会有疑惑，让我来解释下原因：

1. 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来
2. 因为 await 是异步操作，后面的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码，也就是执行了 console.log('1', a) ，输出 '1' 1
3. 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10

上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。

# 移动端开发问题

## position: fixed

1. 随着页面抖动
2. 有输入框时，弹出软键盘会有各种问题
3. 偶尔无法滚动

> 移动端尽量不要使用fixed布局

## -webkit-overflow-scrolling:touch

1. `scrollTop`无法变化
2. 滚动时暂停其他 transition
3. 页面偶尔会卡住不动
4. 在safari上，点击其他区域，再在滚动区域滑动，滚动条无法滚动的bug。
5. 通过动态添加内容撑开容器，结果根本不能滑动的bug。

### 解决方案

1. 如果出现偶尔卡住不动的情况，那么在使用该属性的元素上不设置定位或者手动设置定位为`static`

   ```
   position: static
   ```

2. 如果在-webkit-overflow-scrolling:touch属性的元素上，想通过动态添加内容来撑开容器，触发滚动，是有bug 的，页面是会卡住不动的。

   方法就是在webkit-overflow-scrolling:touch属性的下一层子元素上，将height加1%或1px。从而主动触发scrollbar。

   ```
   <div class="main">
   	<div class="main-inner"></div>
   </div>
   
   .main .main-inner{
   	min-height: 101%;
   }
   // 或
   .main:after {
       min-height: calc(100% + 1px)
   }
   ```

   

## 软键盘弹起

### `IOS` 软键盘弹起表现

在 `IOS` 上，输入框（`input`、`textarea` 或 富文本）获取焦点，键盘弹起，页面（`webview`）并没有被压缩，或者说高度（`height`）没有改变，只是页面（`webview`）整体往上滚了，且最大滚动高度（`scrollTop`）为软键盘高度。

### `Android` 软键盘弹起表现

同样，在 `Android` 上，输入框获取焦点，键盘弹起，但是页面（`webview`）高度会发生改变，一般来说，高度为可视区高度（原高度减去软键盘高度），除了因为页面内容被撑开可以产生滚动，`webview` 本身不能滚动。

### `IOS` 软键盘收起表现

触发软键盘上的“收起”按钮键盘或者输入框以外的页面区域时，输入框失去焦点，软键盘收起。

### `Android` 软键盘收起表现

触发输入框以外的区域时，输入框失去焦点，软键盘收起。但是，触发键盘上的收起按钮键盘时，输入框并不会失去焦点，同样软键盘收起。

### 监听软键盘弹起和收起

```js
// 判断设备类型
var judgeDeviceType = function () {
  var ua = window.navigator.userAgent.toLocaleLowerCase();
  var isIOS = /iphone|ipad|ipod/.test(ua);
  var isAndroid = /android/.test(ua);

  return {
    isIOS: isIOS,
    isAndroid: isAndroid
  }
}()

// 监听输入框的软键盘弹起和收起事件
function listenKeybord($input) {
  if (judgeDeviceType.isIOS) {
    // IOS 键盘弹起：IOS 和 Android 输入框获取焦点键盘弹起
    $input.addEventListener('focus', function () {
      console.log('IOS 键盘弹起啦！');
      // IOS 键盘弹起后操作
    }, false)

    // IOS 键盘收起：IOS 点击输入框以外区域或点击收起按钮，输入框都会失去焦点，键盘会收起，
    $input.addEventListener('blur', () => {
      console.log('IOS 键盘收起啦！');
      // IOS 键盘收起后操作
    })
  }

  // Andriod 键盘收起：Andriod 键盘弹起或收起页面高度会发生变化，以此为依据获知键盘收起
  if (judgeDeviceType.isAndroid) {
    var originHeight = document.documentElement.clientHeight || document.body.clientHeight;

    window.addEventListener('resize', function () {
      var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
      if (originHeight < resizeHeight) {
        console.log('Android 键盘收起啦！');
        // Android 键盘收起后操作
      } else {
        console.log('Android 键盘弹起啦！');
        // Android 键盘弹起后操作
      }

      originHeight = resizeHeight;
    }, false)
  }
}

var $inputs = document.querySelectorAll('.input');

for (var i = 0; i < $inputs.length; i++) {
  listenKeybord($inputs[i]);
}
```

### 让输入框滚动到可视区域

```js
activeElement.scrollIntoView();
```

> 参考文档： https://segmentfault.com/a/1190000018959389

# 懒加载

当对 `<img>` 元素进行懒加载时，我们会通过 JavaScript 来判断 `<img>` 元素是否在视口内，如果元素在视口内，则它的 `src` 属性(有时也用 `srcset`)会用 data-src填充来加载所需的图像内容，初始状态img加载的是一个占位符图片，出现在视口中再进行替换。

```html
<img class="lazy" src="placeholder-image.jpg" data-src="image-to-lazy-load-1x.jpg" data-srcset="image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x" alt="I'm an image!">
```

## 使用`IntersectionObserver`API实现

```js
document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll("img.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target;
          lazyImage.src = lazyImage.dataset.src;
          lazyImage.srcset = lazyImage.dataset.srcset;
          lazyImage.classList.remove("lazy");
          lazyImageObserver.unobserve(lazyImage);
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage);
    });
  } else {
    // Possibly fall back to a more compatible method here
  }
});
```

## 使用事件监听实现

下面介绍使用事件监听，兼容性较好。

**getBoundingClientRect()**：

`getBoundingClientRect`用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置。`getBoundingClientRect`是`DOM`元素到浏览器可视范围的距离（不包含文档卷起的部分）。

判断元素是否在视区

```js
function checkDom(dom){
    let rect = dom.getBoundingClientRect();
    return rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.bottom >=0 && getComputedStyle(dom).display !== "none";
}

// 或
function checkDom(dom){
    let rect = dom.getBoundingClientRect();
     return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && 
        rect.right <= (window.innerWidth || document.documentElement.clientWidth) && 
        getComputedStyle(dom).display !== "none";
    );
}
```

https://github.com/dwqs/blog/issues/74



# performance

## Performance.timing属性详解

- PerformanceTiming.navigationStart 

  表示从同一个浏览器上下文的上一个文档卸载(unload)结束时的UNIX时间戳。如果没有上一个文档，这个值会和`PerformanceTiming.fetchStart`相同。

- PerformanceTiming.unloadEventStart

  表示`unload`事件抛出时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.

- PerformanceTiming.unloadEventEnd

  表示`unload`事件处理完成时的UNIX时间戳。如果没有上一个文档，or if the previous document, or one of the needed redirects, is not of the same origin, 这个值会返回0.

- PerformanceTiming.redirectStart

  表示第一个HTTP重定向开始时的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.

- PerformanceTiming.redirectEnd

  表示最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的UNIX时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.

- **PerformanceTiming.fetchStart**

  表示浏览器准备好使用HTTP请求来获取(fetch)文档的UNIX时间戳。这个时间点会在检查任何应用缓存之前。

- PerformanceTiming.domainLookupStart

  表示域名查询(DNS查询)开始的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 `PerformanceTiming.fetchStart一致。`

- PerformanceTiming.domainLookupEnd

  表示域名查询结束的UNIX时间戳。如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 `PerformanceTiming.fetchStart一致。`

- PerformanceTiming.connectStart

  返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。（TCP连接时间）

- PerformanceTiming.connectEnd

  返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。

- PerformanceTiming.secureConnectionStart（https）

  返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。

- PerformanceTiming.requestStart

  返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。

- **PerformanceTiming.responseStart**

  返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。

- **PerformanceTiming.responseEnd**

  返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。

- **PerformanceTiming.domLoading**

  返回当前网页DOM结构开始解析时（即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)属性变为“loading”、相应的 `readystatechange`事件触发时）的Unix毫秒时间戳。

- **PerformanceTiming.domInteractive**

  返回当前网页DOM结构结束解析、开始加载内嵌资源时（即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState)属性变为“interactive”、相应的`readystatechange`事件触发时）的Unix毫秒时间戳。

- PerformanceTiming.domContentLoadedEventStart

  返回当解析器发送`DOMContentLoaded` 事件，即所有需要被执行的脚本已经被解析时的Unix毫秒时间戳。

- PerformanceTiming.domContentLoadedEventEnd

  返回当所有需要立即执行的脚本已经被执行（不论执行顺序）时的Unix毫秒时间戳。

- **PerformanceTiming.domComplete**

  返回当前文档解析完成，即[`Document.readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState) 变为 `'complete'且相对应的``readystatechange` 被触发时的Unix毫秒时间戳。

- PerformanceTiming.loadEventStart

  返回该文档下，`load`事件被发送时的Unix毫秒时间戳。如果这个事件还未被发送，它的值将会是0。

- PerformanceTiming.loadEventEnd

  返回当`load`事件结束，即加载事件完成时的Unix毫秒时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0.

## 计算性能指标

  - DNS查询： domainLookupEnd - domainLookupStart
  - TCP连接耗时：connectEnd - connectStart
  - request请求耗时：responseEnd - requestStart
  - 解析DOM：domInteractive - domLoading
  - 白屏时间：domLoading - fetchStart
  - domready：domContentLoadedEventEnd - fetchStart
  - onload：loadEventEnd - fetchStart

## 对象字面量{}， new Object()和Object.create()有什么区别？

```js
var s = {},
    k = new Object(),
    k1 = new Object(1), // 等价于 new Number(1);
    h = Object.create({});// 传入的参数即为创建对象的`__proto__`

s.__proto__ === Object.prototype // true
k.__proto__ === Object.prototype // true
k1.__proto__ === Object.prototype // false
k1.__proto__ === Number.prototype // true
h.__proto__ === Object.prototype // false
```

**解释**:

**Object()**

`Object` 构造函数为给定值创建一个对象包装器。如果给定值是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。当以非构造函数形式被调用时，`Object` 等同于 `new Object()`。

**Object.create()**

`Object.create()`方法接受两个参数:`Object.create(obj,propertiesObject)`
`obj`:一个对象，应该是新创建的对象的原型。
`propertiesObject`：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。

Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法,例如：toString(), hasOwnProperty()等方法

Vue源码中的extend就是通过`Object.create`来实现的。

#### new 运算符的执行过程？

1. 一个全新的对象会凭空创建（就是被构建）
2. *这个新构建的对象会被接入原形链（[[Prototype]]-linked）*
3. 这个新构建的对象被设置为函数调用的 `this` 绑定
4. 除非函数返回一个它自己的其他 **对象**，否则这个被 `new` 调用的函数将 *自动* 返回这个新构建的对象。

```js
function new(func){
    let target = {};
    let Constructor = [].shift.call(arguments);
    target.__proto__ = Constructor.prototype;
    var res = Constructor.apply(target, arguments);
    
    return typeof res === 'object' ? res : target;
}
```

## null和undefined

JavaScript的最初版本是这样区分的：**null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。**

```js
Number(null)
// 0

5 + null
// 5

Number(undefined)
// NaN

5 + undefined
// NaN
```

按存储来分析给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null，相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。

给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在，如果是给对象的属性赋值 为undefined，说明这个值为空值

声明了一个变量，但未对其初始化时，这个变量的值就是undefined，它是 JavaScript 基本类型 之一。

```
var data;
console.log(data === undefined); //true
```

**对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型**，使用其他的操作都会报错。

```
//data变量未定义
console.log(typeof data); // "undefined"
console.log(data === undefined); //报错
```

值 `null` 特指对象的值未设置，它是 JavaScript 基本类型 之一。

值 `null` 是一个字面量，它不像[`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined) 是全局对象的一个属性。`null` 是表示缺少的标识，指示变量未指向任何对象。

```
// foo不存在，它从来没有被定义过或者是初始化过：
foo;
"ReferenceError: foo is not defined"

// foo现在已经是知存在的，但是它没有类型或者是值：
var foo = null; 
console.log(foo);	// null
```

## 数组去重

```js
// 排序去重
function unique(array) {
    var res = [];
    var sortedArray = array.concat().sort();
    var seen;
    for (var i = 0, len = sortedArray.length; i < len; i++) {
        // 如果是第一个元素或者相邻的元素不相同
        if (!i || seen !== sortedArray[i]) {
            res.push(sortedArray[i])
        }
        seen = sortedArray[i];
    }
    return res;
}

// Object去重  有问题无法区分1和'1'等
function unique(array) {
    var obj = {};
    return array.filter(function(item, index, array){
        return obj.hasOwnProperty(item) ? false : (obj[item] = true)
    })
}

// Es6
function unique(array) {
   return Array.from(new Set(array));
}

var unique = (a) => [...new Set(a)]

// map
function unique (arr) {
    const seen = new Map()
    return arr.filter((a) => !seen.has(a) && seen.set(a, 1))
}
```

## 类型判断

### typeof

typeof 是一元操作符，放在其单个操作数的前面，操作数可以是任意类型。返回值为表示操作数类型的一个字符串。

```js
typeof 'moshang' // string
```

typeof操作对应的值

| typeof | Undefined | Null   | Boolean | Number | String | Object | Function |
| ------ | --------- | ------ | ------- | ------ | ------ | ------ | -------- |
| 值     | undefined | object | boolean | number | string | object | function |

### instanceof

`instanceof `运算符用来检测 `constructor.prototype `是否存在于参数 `object` 的原型链上。

instanceof 是通过原型链判断的，A instanceof B, 在A的原型链中层层查找，是否有原型等于B.prototype，如果一直找到A的原型链的顶端(null;即Object.prototype.__proto__),仍然不等于B.prototype，那么返回false，否则返回true.

> 对于内置的基础数据类型，`instanceof`的返回值永远都是`false`

```js
'a' instanceof String // false
true instanceof Boolean // false
new Boolean(true) instanceof Boolean // true

```

**insranceof实现**

```js
function instanceof(sub, sup){
    let subPro = sub.__proto__,
        supPro = sup.prototype;

    while(true){
        if(subPro === null){
            return false;
        }else if(subPro === supPro){
            return true;
        }
        subPro = subPro.__proto__;
    }
}
```

### Object.prototype.toString

```js
// 以下是11种：
var number = 1;          // [object Number]
var string = '123';      // [object String]
var boolean = true;      // [object Boolean]
var und = undefined;     // [object Undefined]
var nul = null;          // [object Null]
var obj = {a: 1}         // [object Object]
var array = [1, 2, 3];   // [object Array]
var date = new Date();   // [object Date]
var error = new Error(); // [object Error]
var reg = /a/g;          // [object RegExp]
var func = function a(){}; // [object Function]

console.log(Object.prototype.toString.call(Math)); // [object Math]
console.log(Object.prototype.toString.call(JSON)); // [object JSON]

function a() {
    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]
}
a();
```

### type API

```js
var class2type = {};

// 生成class2type映射
"Boolean Number String Function Array Date RegExp Object Error".split(" ").map(function(item, index) {
    class2type["[object " + item + "]"] = item.toLowerCase();
})

function type(obj) {
    // 一箭双雕
    if (obj == null) {
        return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[Object.prototype.toString.call(obj)] || "object" :
        typeof obj;
}
```

### plainObject

除了 {} 和 new Object 创建的之外，jQuery 认为一个没有原型的对象也是一个纯粹的对象。

```js
// 相当于 Object.prototype.toString
var toString = ({}).toString;
// 相当于 Object.prototype.hasOwnProperty
var hasOwn = ({}).hasOwnProperty;

function isPlainObject(obj) {
    var proto, Ctor;

    // 排除掉明显不是obj的以及一些宿主对象如Window
    if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
    }

    /**
     * getPrototypeOf es5 方法，获取 obj 的原型
     * 以 new Object 创建的对象为例的话
     * obj.__proto__ === Object.prototype
     */
    proto = Object.getPrototypeOf(obj);

    // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true
    if (!proto) {
        return true;
    }

    /**
     * 以下判断通过 new Object 方式创建的对象
     * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor
     * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数
     */
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;

    // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数
    // hasOwn.toString返回当前函数源代码的字符串，参考Function.prototype.toString
    return typeof Ctor === "function" && hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object); 
}
```



### EmptyObject

jQuery提供了 `isEmptyObject` 方法来判断是否是空对象，代码简单，我们直接看源码：

```js
function isEmptyObject( obj ) {

        var name;

        for ( name in obj ) {
            return false;
        }

        return true;
}
```

### window

```js
function isWindow( obj ) {
    return obj != null && obj === obj.window;
}
```

### isArrayLike

```js
function isArrayLike(obj) {

    // obj 必须有 length属性
    var length = !!obj && "length" in obj && obj.length;
    var typeRes = type(obj);

    // 排除掉函数和 Window 对象
    if (typeRes === "function" || isWindow(obj)) {
        return false;
    }

    return typeRes === "array" || length === 0 ||
        typeof length === "number" && length > 0 && (length - 1) in obj;
}
```

#### 思考题

```
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// --> undefined
b.x 	// --> {n: 2}
```

答案已经写上面了，这道题的关键在于

- 1、优先级。`.`的优先级高于`=`，所以先执行`a.x`，堆内存中的`{n: 1}`就会变成`{n: 1, x: undefined}`，改变之后相应的`b.x`也变化了，因为指向的是同一个对象。
- 2、赋值操作是`从右到左`，所以先执行`a = {n: 2}`，`a`的引用就被改变了，然后这个返回值又赋值给了`a.x`，**需要注意**的是这时候`a.x`是第一步中的`{n: 1, x: undefined}`那个对象，其实就是`b.x`，相当于`b.x = {n: 2}`

# ['1', '2', '3'].map(parseInt) what and why

先上结果：

```js
[1, NaN, NaN]
```

首先需要了解两个函数`parseInt`和`map`

### [parseInt(string, radix)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)

**parseInt(string, radix)**  string为字符串，radix为介于2-36之间的数。使用者告诉这个函数string（比如11）是radix（比如2）进制的，函数将固定返回string以十进制时显示的数（3）;

#### 参数

- `string`

  要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  `ToString `抽象操作)。字符串开头的空白符将会被忽略。

- `radix`

  一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的**基数**。比如参数"10"表示使用我们通常使用的十进制数值系统。**始终指定此参数**可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为**10**。

#### 返回值

返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)。

注意：`radix`参数为n 将会把第一个参数看作是一个数的n进制表示，而返回的值则是十进制的。例如：

```html
parseInt('123', 5) // 将'123'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38
```

如果 `parseInt` 遇到了不属于`radix`参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。`parseInt` 将截取整数部分。开头和结尾的空白符允许存在，会被忽略。

**注意：**

在基数为 `undefined`，或者基数为 0 或者没有指定的情况下，JavaScript 作如下处理：

- 如果字符串 `string` 以"0x"或者"0X"开头, 则基数是16 (16进制).
- 如果字符串 `string` 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，**永远都要明确给出radix参数的值**。
- 如果字符串 `string` 以其它任何值开头，则基数是10 (十进制)。

如果第一个字符不能被转换成数字，`parseInt`返回`NaN`。

算术上， `NaN` 不是任何一个进制下的数。 你可以调用[`isNaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN) 来判断 `parseInt` 是否返回 `NaN`。`NaN` 参与的数学运算其结果总是 `NaN`。

### [map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

`map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

```
var new_array = arr.map(function callback(currentValue[,index[, array]]) {
 // Return element for new_array
 }[, thisArg])
```

可以看到`callback`回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。
`currentValue` 是callback 数组中正在处理的当前元素。
`index`可选, 是callback 数组中正在处理的当前元素的索引。
`array`可选, 是callback map 方法被调用的数组。
另外还有`thisArg`可选, 执行 callback 函数时使用的this 值。

```
const arr = [1, 2, 3];
arr.map((num) => num + 1); // [2, 3, 4]
```

### 再看题目

```js
['1', '2', '3'].map(parseInt)
```

实际执行代码为：

```js
['1', '2', '3'].map((item, i) => {
  	return parseInt(item, i);
})
```

返回值为：

```js
parseInt('1', 0) //1
parseInt('2', 1) //NAN
parseInt('3', 2) //NAN, 2进制表示的数中，最大值小于3，所以无法解析
```

### 扩展 -> Number()转换规则

如果是boolean值，true和false将分别转换为十进制数值
如果是数字值，只是简单的传入与返回
如果是null， 返回0
如果是undefined ，返回NaN
如果是字符串，遵循下列原则：
 `1.只包含数字，八进制的数值将会被忽略前面的0，直接显示为十进制 如：“011” 应为 ‘9’但只能转换为‘11’；`
 `2.浮点数可以转换为对应的浮点数值`
 `3.如果是十六进制会转换为十进制值`
 `4.如果字符串为空转换为0`
 `5.其他转为NaN`

```js
Number(new Date()) // 1562075861887
Number('100n') // NAN
parseInt('100n') // 100
Number("123")       //123     字符串
Number("")          //0       字符串
Number(true)        //1       布尔
Number(null)        //0       对象
Number(1.1)         //1.1     浮点数
Number('011')       //11      八进制
Number('0x11')      //17      16进制
```

# 防抖，节流

**防抖**：触发高频事件后n秒内只会执行一次，如果n秒内再次触发，则重新计算时间

```js
/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   delay       表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数，在delay时间内连续调用都不执行，且只执行一次
 * @return {function}             返回客户调用函数
 */
function debounce(fn, delay = 50，immediate = true){
	let timer, context, args;
  
  function later(){
    return setTimeout(() => {
			timer = null;
      // immediate: true, 表示目标函数知执行一次，之后再也不执行
      if(!immediate){
				fn.call(context, args);
        context = args = null;
      }
    }, delay);
  }
  
  return function(){
    if(!timer){
      timer = later();
      if(immediate){
				fn.call(this, arguments);
      }else{
        context = this;
        args = arguments;
      }
    }else{
      clearTimeout(timer);
      timer = later();
    }
  }
}
```

# background

background属性的简写用法, 常见背景属性的理解。

### background属性

background简写属性在一个声明中可设置所有的背景属性。

可设置属性如下:

- `background-image`: 设置背景图像, 可以是真实的图片路径, 也可以是创建的渐变背景;
- `background-position`: 设置背景图像的位置;
- `background-size`: 设置背景图像的大小;
- `background-repeat`: 指定背景图像的铺排方式;
- `background-attachment`: 指定背景图像是滚动还是固定;
- `background-origin`: 设置背景图像显示的原点[background-position相对定位的原点];
- `background-clip`: 设置背景图像向外剪裁的区域;
- `background-color`: 指定背景颜色。

简写的顺序如下:

```
 bg-color || bg-image || bg-position [ / bg-size]? || bg-repeat || bg-attachment || bg-origin || bg-clip
```

**顺序并非固定, 但是要注意:**

1. background-position 和 background-size 属性, 之间需使用/分隔, 且position值在前, size值在后。
2. 如果同时使用 background-origin 和 background-clip 属性, origin属性值需在clip属性值之前, 如果origin与clip属性值相同, 则可只设置一个值。

代码示例:

```
background: url("image.png") 10px 20px/100px no-repeat content-box;
```

background是一个复合属性, 可设置多组属性, 每组属性间使用逗号分隔, 其中**背景颜色不能设置多个且只能放在最后一组**。

如设置的多组属性背景图像之间存在重叠, 则前面的背景图像会覆盖在后面的背景图像上。

代码示例:

```
padding: 10px;
background: url("image.png") 0% 0%/60px 60px no-repeat padding-box,
            url("image.png") 40px 10px/110px 110px no-repeat content-box,
            url("image.png") 140px 40px/200px 100px no-repeat content-box #58a;
```



### 常见背景属性

**background-position**

background-position属性用来设置背景图像的位置, 默认值: 0% 0%, 效果等同于 left top。

取值说明:

1. 如果设置一个值, 则该值作用在横坐标上, 纵坐标默认为50%(即center) ;
2. 如果设置两个值, 则第一个值作用于横坐标, 第二个值作用于纵坐标, 取值可以是方位关键字[left\top\center\right\bottom], 如 `background-position: left center ;` 也可以是百分比或长度, 百分比和长度可为设置为负值, 如: `background-position: 10% 30px ;`
3. 另外css3支持3个值或者4个值, 注意如果设置3个或4个值, `偏移量前必须有关键字`, 如: `background-position: right 20px bottom 30px;`



也可以使用 `background-position-x` 或 `background-position-y` 来分别设置横坐标或纵坐标的偏移量。

注意: 当使用 background-position-x 以及 background-position-y 时, 需考虑Firefox兼容性的问题。

**background-size**

background-size 属性用来指定背景图像的大小。默认值: auto

取值说明: 

1. 可使用 长度值 或 百分比 指定背景图像的大小, 值不能为负值。

   如果设置一个值, 则该值用于定义图像的宽度, 图像的高度为默认值`auto`, 根据宽度进行等比例缩放; 如果设置两个值, 则分别作用于图像的宽和高。 

2. `auto`默认值, 即图像真实大小。 

3. `cover`将背景图像等比缩放到完全覆盖容器, 背景图像有可能超出容器。(即当较短的边等于容器的边时, 停止缩放) 

4. `contain`将背景图像等比缩放到宽度或高度与容器的宽度或高度相等, 背景图像始终被包含在容器内。(即当较长的边等于容器的边时, 停止缩放)

**background-repeat**

background-repeat 属性用来设置背景图像铺排填充方式, 默认值: repeat 。

取值说明: 

1. repeat-x 表示横向上平铺, 相当于设置两个值 repeat no-reapeat; 
2. repeat-y 表示纵向上平铺, 相当于设置两个值 no-repeat repeat; 
3. repeat 表示横向纵向上均平铺; 
4. no-repeat 表示不平铺; 
5. round 表示背景图像自动缩放直到适应且填充满整个容器。 注意: 当设置为 round 时, background-size 的 cover 和 contain 属性失效。
6. space 表示背景图像以相同的间距平铺且填充满整个容器或某个方向. 注意: 当 background-size 设置为 cover 和 contain 时, background-rapeat 的 space 属性失效。

注意, background-repeat 的 round/space 属性, 部分Firefox版本不支持。

**background-origin**

用于设置 `background-position` 定位时参考的原点, 默认值 `padding-box` , 另外还有两个值: `border-box` 和 `content-box`。

代码示例:

```
border: 10px solid #58A;
padding: 20px;
background-position: 10px 20px;
```

**background-attachment**

- background-attachment: scroll

scroll 此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动。

- background-attachment: local

local 此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。

- background-attachment: fixed

fixed 此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。背景图从一开始就已经被固定死在初始所在的位置。可用于实现滚动视差，见例子：

<https://www.cnblogs.com/coco1s/p/9453938.html>

<https://kilianvalkhof.com/2010/design/the-problem-with-svg-and-canvas/>

> 注意一下 scroll 与 fixed，一个是相对元素本身固定，一个是相对视口固定，有点类似 `position` 定位的 `absolute` 和 `fixed`。

# 0.1 + 0.2  !== 0.3 why?

因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。

我们都知道计算机表示十进制是采用二进制表示的，所以 `0.1` 在二进制表示为

```js
// (0011) 表示循环
0.1 = 0.0001(1001)...
```

**小数转2进制过程**：将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，直到小数部分为0。 
**特殊情况：** 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因

```js
// 0.1二进制演算过程如下
0.1 * 2 = 0.2 // 记录0
0.2 * 2 = 0.4 // 记录0
0.4 * 2 = 0.8 // 记录0
0.8 * 2 = 1.6 // 记录1
0.6 * 2 = 1.2 // 记录1
0.2 * 2 = 0.4 // 记录0
0.2 * 2 = 0.4 // 记录0
0.4 * 2 = 0.8 // 记录0
0.8 * 2 = 1.6 // 记录1
0.6 * 2 = 1.2 // 记录1
... // 如此循环下去
0.1 = 0.0001100110011001...
```

 IEEE 754 双精度。六十四位中符号位占一位，整数位占一位，其余五十二位都为小数位。因为 **`0.1` 和 `0.2` 都是无限循环的二进制**了，所以**在小数位末尾处需要判断是否进位**（就和十进制的四舍五入一样）。	故`0.1`进位后表示为`0.0001(1001*11次)1010`，同理`0.2`表示为`0.(0011*12次)0100`。那么把这两个二进制加起来会得出 `0.0100(1100*11次)1110` , 这个值算成十进制就是 `0.30000000000000004`

下面说一下原生解决办法，如下代码所示

```js
parseFloat((0.1 + 0.2).toFixed(10))
```

# NaN

`NaN` 是一个全局对象的属性。

NaN 属性的初始值就是 NaN，和 `Number.NaN` 的值一样。在现代浏览器中（ES5中）， `NaN` 属性是一个不可配置（non-configurable），不可写（non-writable）的属性。

### 判断一个值是否是NaN

等号运算符（`==` 和 `===）` 不能被用来判断一个值是否是 `NaN`。必须使用 [`Number.isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)或 [`isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN) 函数。在执行自比较之中：NaN，**也只有NaN，比较之中不等于它自己**。

```js
NaN == NaN;         // false
NaN === NaN;        // false
Number.NaN === NaN; // false
isNaN(NaN);         // true
isNaN(Number.NaN);  // true

function valueIsNaN(v) { return v !== v; }
valueIsNaN(1);          // false
valueIsNaN(NaN);        // true
valueIsNaN(Number.NaN); // true
```

### isNaN

**isNaN()**函数用来确定一个值是否为[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 。

如果给定值为 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)则返回值为`true`；否则为`false`。

 JavaScript 中其他的值不同，[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)不能通过相等操作符（== 和 ===）来判断 ，因为 `NaN == NaN` 和 `NaN === NaN` 都会返回 `false`。 因此，`isNaN` 就很有必要了。

#### 怪异行为

如果`isNaN`函数的参数不是`Number`类型， `isNaN`函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)进行判断。

通过[`Number.isNaN(x)`](#Number.isNaN)来检测变量`x`是否是一个`NaN`将会是一种可靠的做法。然而，在缺少`Number.isNaN`函数的情况下, 通过表达式`(x != x)` 来检测`变量x`是否是`NaN`会更加可靠。

**示例**：

```js
isNaN(NaN);       // true
isNaN(undefined); // true
isNaN({});        // true

isNaN(true);      // false
isNaN(null);      // false
isNaN(37);        // false

// strings
isNaN("37");      // false: 可以被转换成数值37
isNaN("37.37");   // false: 可以被转换成数值37.37
isNaN("37,5");    // true
isNaN('123ABC');  // true:  parseInt("123ABC")的结果是 123, 但是Number("123ABC")结果是 NaN
isNaN("");        // false: 空字符串被转换成0
isNaN(" ");       // false: 包含空格的字符串被转换成0 Number('     ')结果是0

// dates
isNaN(new Date());                // false
isNaN(new Date().toString());     // true
isNaN("blabla")   // true: "blabla"不能转换成数值转换成数值失败， 返回NaN
```

### Number.isNaN

**Number.isNaN()** 方法确定传递的值是否为 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)和其类型是 [`Number`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number)。它是原始的全局[`isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN)的更强大的版本。

和全局函数 [`isNaN()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/isNaN) 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 `NaN` 的时候才会返回 `true`。

**示例**：

```js
Number.isNaN(NaN);        // true
Number.isNaN(Number.NaN); // true
```

# 深度优先遍历和广度优先遍历

首先初始化一个需要遍历的html结构，如下：

[![image](https://user-images.githubusercontent.com/27856388/52606290-118a3180-2ead-11e9-86b7-d0feae6f8030.png)](https://user-images.githubusercontent.com/27856388/52606290-118a3180-2ead-11e9-86b7-d0feae6f8030.png)

我将用深度优先遍历和广度优先遍历对这个dom树进行查找

### 深度优先遍历

#### 深度优先遍历（DFS）

深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所有边都已被探寻过，将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。

简单的说，DFS就是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。

DFS 可以产生相应图的拓扑排序表，利用拓扑排序表可以解决很多问题，例如最大路径问题。一般用堆数据结构来辅助实现DFS算法。

**注意：深度DFS属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。**

**步骤：**

- 访问顶点v
- 依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问
- 若此时途中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到所有顶点均被访问过为止

**实现：**

```js
// 实现一
function deepTraversal(node, nodeList = []){
  if(!node){
    return nodeList;
  }
  nodeList.push(node);
  let children = node.children;
  children.forEach(item => {
		deepTraversal(item, nodeList);
  });
  return nodeList;
}

// 实现二
function deepTraversal(node){
  let nodeList = [];
  if (node !== null) {
    nodeList.push(node)
    let children = node.children
  	children.forEach(item => {
      nodeList = nodeList.concat(deepTraversal1(item));
    });
  }
  return nodeList;
}

// 实现三，非递归
function deepTraversal(node){
  let nodeList = [],
      task = [];
  
  if (node) {
    // 推入当前处理的node
    task.push(node)
    while (task.length) {
      let item = task.pop()
      let children = item.children
      nodeList.push(item)
      // node = [] stack = [parent]
      // node = [parent] stack = [child3,child2,child1]
      // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]
      // node = [parent, child1-1] stack = [child3,child2,child1-2]
      for (let i = children.length - 1; i >= 0; i--) {
        task.push(children[i])
      }
    }
  }
  return nodeList;
}
```

### 广度优先遍历

#### 广度优先遍历（BFS）

广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现BFS

**BFS从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层**

**步骤：**

- 创建一个队列，并将开始节点放入队列中
- 若队列非空，则从队列中取出第一个节点，并检测它是否为目标节点
  - 若是目标节点，则结束搜寻，并返回结果
  - 若不是，则将它所有没有被检测过的子节点都加入队列中
- 若队列为空，表示图中并没有目标节点，则结束遍历

**实现：**

```js
function widthTraversal2(node){
  let nodeList = []
  let task = []
  if (node) {
    task.push(node)
    while (task.length) {
      let item = task.shift()
      let children = item.children
      nodeList.push(item)
        // 队列，先进先出
        // nodes = [] stack = [parent]
        // nodes = [parent] stack = [child1,child2,child3]
        // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
        // nodes = [parent,child1,child2]
      for (let i = 0; i < children.length; i++) {
        task.push(children[i])
      }
    }
  }
  return nodeList;
}
```

## 请分别用深度优先思想和广度优先思想实现一个拷贝函数？

```js
function getType(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1);
}

function getConstructor(obj) {
    let type = getType(obj),
        isSame = true;

    if (type === 'Object' || type === 'Array') {
        obj = obj.constructor();
        isSame = false;
    } else if (type === 'Date') {
        obj = new Date(obj);
    } else if (type === 'RegExp') {
        obj = new RegExp(obj);
    }

    return {
        isSame,
        obj
    };
}

// 广度优先遍历
function deepCloneBFS(obj) {
    let cons = getConstructor(obj),
        stack = [],
        map = new Map(), // 用于处理循环引用
        _obj = cons.obj;

    if (cons.isSame) {
        return _obj;
    }

    stack.push([obj, _obj]);
    map.set(obj, _obj);

    while (stack.length > 0) {
        let [ori, tar] = stack.shift();
        for (let key in ori) {
            // 用于处理循环引用
            if (map.get(ori[key])) {
                tar[key] = map.get(ori[key]);
                continue;
            }

            let data = getConstructor(ori[key]);
            tar[key] = data.obj;
            if (data.isSame) {
                continue;
            }
            stack.push([ori[key], tar[key]]);
            map.set(ori[key], tar[key]);
        }
    }
}

// 深度优先遍历
// 处理循环引用
function deepCloneDFS(obj) {
    let data = getConstructor(obj);
    let _obj = data.obj;
    if (data.isSame) {
        return _obj;
    }

    for (let key in obj) {
        _obj[key] = deepCloneDFS(obj[key]);
    }
    return _obj;
}
```

# 作用域和闭包

## 词法作用域

函数的词法作用域是由这个函数被声明的位置 **唯一** 定义的。

作用域的查询匹配是从当前作用域开始，逐级向上查找的，**一旦找到第一个匹配，作用域查询就停止了**。

在一个作用域中声明的任何变量都附着在这个作用域上。

## 提升

*引擎* 会在它解释执行你的 JavaScript 代码之前编译它。编译过程的一部分就是找到所有的声明，并将它们关联在合适的作用域上。所以在你的代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。

当你看到 `var a = 2;` 时，你可能认为这是一个语句。但是 JavaScript 实际上认为这是两个语句：`var a;` 和 `a = 2;`。第一个语句，声明，是在编译阶段被处理的。第二个语句，赋值，为了执行阶段而留在 **原处**。

**注意：** 只有声明本身被提升了，而任何赋值或者其他的执行逻辑都被留在 *原处*。

函数声明会被提升，就像我们看到的。但是函数表达式不会。如下所示：

```js
foo(); // 不是 ReferenceError， 而是 TypeError!

var foo = function bar() {
	// ...
};
```

### 函数优先

函数声明和变量声明都会被提升。函数会首先被提升，然后才是变量。

```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};
```

这个代码段被 *引擎* 解释执行为：

```js
function foo() {
	console.log( 1 );
}

foo(); // 1

foo = function() {
	console.log( 2 );
};
```

> 多个/重复的 `var` 声明实质上是被忽略的，但是后续的函数声明确实会覆盖前一个。

```js
foo(); // 3

function foo() {
	console.log( 1 );
}

var foo = function() {
	console.log( 2 );
};

function foo() {
	console.log( 3 );
}
```

## 闭包

**闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。**

# this

`this` 不会以任何方式指向函数的 **词法作用域**。`this` 既不是函数自身的引用，也不是函数 *词法* 作用域的引用。`this` 不是编写时绑定，而是运行时绑定。`this` 实际上是在函数被调用时建立的一个绑定，它指向 *什么* 是完全由函数被调用的**调用点**来决定的。

**调用点**：函数在代码中被调用的位置不是被申明的位置。

如下是调用点使用的四种规则：

## 默认绑定

独立函数调用，这种 `this` 规则是在没有其他规则适用时的默认规则， `this` 指向了全局对象。

```js
function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 2
```

们考察调用点来看看 `foo()` 是如何被调用的。在我们的代码段中，`foo()` 是被一个直白的，毫无修饰的函数引用调用的。没有其他的我们将要展示的规则适用于这里，所以 *默认绑定* 在这里适用。

## 隐含绑定

调用点是否有一个环境对象（context object），也称为拥有者（owning）或容器（containing）对象

```js
function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 2
```

调用点 *使用* `obj` 环境来 **引用** 函数，所以你 *可以说* `obj` 对象在函数被调用的时间点上“拥有”或“包含”这个 **函数引用**。在 `foo()` 被调用的位置上，它被冠以一个指向 `obj` 的对象引用。当一个方法引用存在一个环境对象时，*隐含绑定* 规则会说：是这个对象应当被用于这个函数调用的 `this` 绑定。

> `strict mode` 下是 `undefined`，否则就是全局对象。

## 明确绑定

call， apply

如果你传递 `null` 或 `undefined` 作为 `call`、`apply` 或 `bind` 的 `this` 绑定参数，那么这些值会被忽略掉，取而代之的是 *默认绑定* 规则将适用于这个调用

## 判定 `this`

现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定 `this` 的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。

1. 函数是通过 `new` 被调用的吗（**new 绑定**）？如果是，`this` 就是新构建的对象。

   `var bar = new foo()`

2. 函数是通过 `call` 或 `apply` 被调用（**明确绑定**），甚至是隐藏在 `bind` *硬绑定* 之中吗？如果是，`this` 就是那个被明确指定的对象。

   `var bar = foo.call( obj2 )`

3. 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（**隐含绑定**）？如果是，`this` 就是那个环境对象。

   `var bar = obj1.foo()`

4. 否则，使用默认的 `this`（**默认绑定**）。如果在 `strict mode` 下，就是 `undefined`，否则是 `global`对象。

   `var bar = foo()`

以上，就是理解对于普通的函数调用来说的 `this` 绑定规则 *所需的全部*。是的……几乎是全部。

## 词法 this

Es6箭头函数的`this`与使用四种标准的 `this` 规则不同的是，箭头函数从封闭它的（函数或全局）作用域采用 `this` 绑定。一个箭头函数的词法绑定是不能被覆盖的（就连 `new` 也不行！）。

# 对象

## 类型

对象是大多数 JS 程序依赖的基本构建块儿。它们是 JS 的六种主要类型（在语言规范中称为“语言类型”）中的一种：

- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `object`

### 内建对象

有几种其他的对象子类型，通常称为内建对象。对于其中的一些来说，它们的名称看起来暗示着它们和它们对应的基本类型有着直接的联系，但事实上，它们的关系更复杂，我们一会儿就开始探索。

- `String`
- `Number`
- `Boolean`
- `Object`
- `Function`
- `Array`
- `Date`
- `RegExp`
- `Error`

基本类型值 `"I am a string"` 不是一个对象，它是一个不可变的基本字面值。为了对它进行操作，比如检查它的长度，访问它的各个独立字符内容等等，都需要一个 `String` 对象。

幸运的是，在必要的时候语言会自动地将 `"string"` 基本类型强制转换为 `String` 对象类型，这意味着你几乎从不需要明确地创建对象。

考虑下面的代码：

```
var strPrimitive = "I am a string";

console.log( strPrimitive.length );			// 13

console.log( strPrimitive.charAt( 3 ) );	// "m"
```

在这两个例子中，我们在字符串的基本类型上调用属性和方法，引擎会自动地将它强制转换为 `String` 对象，所以这些属性/方法的访问可以工作。

当使用如 `42.359.toFixed(2)` 这样的方法时，同样的强制转换也发生在数字基本字面量 `42` 和包装对象 `new Number(42)` 之间。同样的还有 `Boolean` 对象和 `"boolean"` 基本类型。

`null` 和 `undefined` 没有对象包装的形式，仅有它们的基本类型值。相比之下，`Date` 的值 *仅可以* 由它们的构造对象形式创建，因为它们没有对应的字面形式。

声明一个函数表达式作为字面对象的一部分，那个函数都不会魔法般地 *属于* 这个对象 —— 仍然仅仅是同一个函数对象的多个引用罢了。

## 拷贝

浅拷贝和深拷贝，`Object.assign()`就是一个内置的浅拷贝。

### Object.assign

`writable`，`enumerable`，` configurable`都为false的属性不会被拷贝，且不会带上拷贝对象的属性描述，拷贝的属性的三个值都为`true`。

## 内容

### 属性描述符

**Object.defineProperty**，**getOwnPropertyDescriptor**

```js
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: true, // 可配置的，该操作为单向操作不可撤销。
	enumerable: true
} );

myObject.a; // 2
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
//    value: 2,
//    writable: true,
//    enumerable: true,
//    configurable: true
// }
```

#### 可写性（Writable）

`writable` 控制着你改变属性值的能力。

**注意：** `writable:false` 意味着值不可改变，和你定义一个空的 setter 是有些等价的。实际上，你的空 setter 在被调用时需要扔出一个 `TypeError`，来和 `writable:false` 保持一致。

#### 可配置性（Configurable）

只要属性当前是可配置的，我们就可以使用相同的 `defineProperty(..)` 工具，修改它的描述符定义。

```
var myObject = {
	a: 2
};

myObject.a = 3;
myObject.a;					// 3

Object.defineProperty( myObject, "a", {
	value: 4,
	writable: true,
	configurable: false,	// 不可配置！
	enumerable: true
} );

myObject.a;					// 4
myObject.a = 5;
myObject.a;					// 5

Object.defineProperty( myObject, "a", {
	value: 6,
	writable: true,
	configurable: true,
	enumerable: true
} ); // TypeError
```

最后的 `defineProperty(..)` 调用导致了一个 TypeError，这与 `strict mode` 无关，如果你试图改变一个不可配置属性的描述符定义，就会发生 TypeError。要小心：如你所看到的，将 `configurable` 设置为 `false` 是 **一个单向操作，不可撤销！**

**注意：** 这里有一个需要注意的微小例外：即便属性已经是 `configurable:false`，`writable` 总是可以没有错误地从 `true`改变为 `false`，但如果已经是 `false` 的话不能变回 `true`。

`configurable:false` 阻止的另外一个事情是使用 `delete` 操作符移除既存属性的能力。

#### 可枚举性（Enumerable）

它的名称可能已经使它的功能很明显了，这个性质控制着一个属性是否能在特定的对象-属性枚举操作中出现，比如 `for..in` 循环。设置为 `false` 将会阻止它出现在这样的枚举中，即使它依然完全是可以访问的。设置为 `true` 会使它出现。

#### 对象常量（Object Constant）

通过将 `writable:false` 与 `configurable:false` 组合，你可以实质上创建了一个作为对象属性的 *常量*（不能被改变，重定义或删除），比如：

```
var myObject = {};

Object.defineProperty( myObject, "FAVORITE_NUMBER", {
	value: 42,
	writable: false,
	configurable: false
} );
```

#### 防止扩展（Prevent Extensions）

如果你想防止一个对象被添加新的属性，但另一方面保留其他既存的对象属性，可以调用 `Object.preventExtensions(..)`：

```
var myObject = {
	a: 2
};

Object.preventExtensions( myObject );

myObject.b = 3;
myObject.b; // undefined
```

在非 `strict mode` 模式下，`b` 的创建会无声地失败。在 `strict mode` 下，它会抛出 `TypeError`。

#### 封印（Seal）

`Object.seal(..)` 创建一个“封印”的对象，这意味着它实质上在当前的对象上调用 `Object.preventExtensions(..)`，同时也将它所有的既存属性标记为 `configurable:false`。

所以，你既不能添加更多的属性，也不能重新配置或删除既存属性（虽然你依然 *可以* 修改它们的值）。

#### 冻结（Freeze）

`Object.freeze(..)` 创建一个冻结的对象，这意味着它实质上在当前的对象上调用 `Object.seal(..)`，同时也将它所有的“数据访问”属性设置为 `writable:false`，所以它们的值不可改变。

### Getters 与 Setters

ES5 引入了一个方法来覆盖这些默认操作的一部分，但不是在对象级别而是针对每个属性，就是通过 getters 和 setters。Getter 是实际上调用一个隐藏函数来取得值的属性。Setter 是实际上调用一个隐藏函数来设置值的属性。

当你将一个属性定义为拥有 getter 或 setter 或两者兼备，那么它的定义就成为了“访问器描述符”（与“数据描述符”相对）。**对于访问器描述符，它的 `value` 和 `writable` 性质因没有意义而被忽略**，取而代之的是 JS 将会考虑属性的 `set` 和 `get` 性质（还有 `configurable` 和 `enumerable`）。

```
var myObject = {
	// 为 `a` 定义 getter
	get a() {
		return this._a_;
	},

	// 为 `a` 定义 setter
	set a(val) {
		this._a_ = val * 2;
	}
};

myObject.a = 2;

myObject.a; // 4
```

### 存在性（Existence）

我们可以查询一个对象是否拥有特定的属性，而 *不必* 取得那个属性的值：

```
var myObject = {
	a: 2
};

("a" in myObject);				// true
("b" in myObject);				// false

myObject.hasOwnProperty( "a" );	// true
myObject.hasOwnProperty( "b" );	// false
```

`in` 操作符会检查属性是否存在于对象 *中*，或者是否存在于 `[[Prototype]]` 链对象遍历的更高层中（详见第五章）。相比之下，`hasOwnProperty(..)` *仅仅* 检查 `myObject` 是否拥有属性，但 *不会* 查询 `[[Prototype]]` 链。

```js

```



#### 枚举（Enumeration）

```js
var myObject = { };

Object.defineProperty(
	myObject,
	"a",
	// 使 `a` 可枚举，如一般情况
	{ enumerable: true, value: 2 }
);

Object.defineProperty(
	myObject,
	"b",
	// 使 `b` 不可枚举
	{ enumerable: false, value: 3 }
);

myObject.b; // 3
("b" in myObject); // true
myObject.hasOwnProperty( "b" ); // true

// .......

for (var k in myObject) {
	console.log( k, myObject[k] );
}
// "a" 2

myObject.propertyIsEnumerable( "a" ); // true
myObject.propertyIsEnumerable( "b" ); // false

Object.keys( myObject ); // ["a"]
Object.getOwnPropertyNames( myObject ); // ["a", "b"]
```

> `for in`和`Object.key()`只能枚举`enumerable`为`true`的属性

```js
let obj = Object.create({a:1});
obj.b = 2;

Object.keys(obj); // ["b"]
for(let key in obj){
    console.log(key); // b a
}
'a' in obj // true
```

[https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20&%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes](https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this & object prototypes/README.md#you-dont-know-js-this--object-prototypes)

# 原型和行为委托

## [[Prototype]]

JavaScript 中的对象有一个内部属性，在语言规范中称为 `[[Prototype]]`，它只是一个其他对象的引用。几乎所有的对象在被创建时，它的这个属性都被赋予了一个非 `null` 值，通常称为“原型”。

`[[Prototype]]` 引用有什么用？先看对象属性取值操作`[[Get]]`

### [[Get]]	 	

如果默认的 `[[Get]]` 操作不能直接在对象上找到被请求的属性，那么它会沿着对象的 `[[Prototype]]` **链** 继续处理。

看如下代码：

```
var anotherObject = {
	a: 2
};

// 创建一个链接到 `anotherObject` 的对象
var myObject = Object.create( anotherObject );

myObject.a; // 2
```

获取`myObject`属性`a`的值，对于默认的 `[[Get]]` 操作来说，第一步就是检查对象本身是否拥有一个 `a` 属性，如果有，就使用它。本示例中是没有的，进入第二步。第二步如果 `myObject` 上 **不** 存在 `a` 属性时，我们就将注意力转向对象的 `[[Prototype]]` 链。现在让 `myObject` `[[Prototype]]` 链到了 `anotherObject`，在 `anotherObject` 中找到了，而且确实找到了值 `2`。但是，如果在 `anotherObject` 上也没有找到 `a`，而且如果它的 `[[Prototype]]` 链不为空，就沿着它继续查找。

这个处理持续进行，直到找到名称匹配的属性，或者 `[[Prototype]]` 链终结。如果在链条的末尾都没有找到匹配的属性，那么 `[[Get]]` 操作的返回结果为 `undefined`。

对于在对象上添加新属性或改变既存属性的值，情况会更复杂一些，

### [[Put]] 与属性屏蔽

```
myObject.foo = "bar";
```

如果 `myObject` 对象已经直接拥有了普通的名为 `foo` 的数据访问器属性，那么这个赋值就和改变既存属性的值一样简单。

如果 `foo` 还没有直接存在于 `myObject`，`[[Prototype]]` 就会被遍历，就像 `[[Get]]` 操作那样。如果在链条的任何地方都没有找到 `foo`，那么就会像我们期望的那样，属性 `foo` 就以指定的值被直接添加到 `myObject` 上。

然而，如果 `foo` 已经存在于链条更高层的某处，`myObject.foo = "bar"` 赋值就可能会发生微妙的（也许令人诧异的）行为。

如果属性名 `foo` 同时存在于 `myObject` 本身和从 `myObject` 开始的 `[[Prototype]]` 链的更高层，这样的情况称为 *遮蔽*。直接存在于 `myObject` 上的 `foo` 属性会 *遮蔽* 任何出现在链条高层的 `foo` 属性，因为 `myObject.foo` 查询总是在寻找链条最底层的 `foo` 属性。

正如我们被暗示的那样，在 `myObject` 上的 `foo` 遮蔽没有看起来那么简单。我们现在来考察 `myObject.foo = "bar"` 赋值的三种场景，当 `foo` **不直接存在** 于 `myObject`，但 **存在** 于 `myObject` 的 `[[Prototype]]` 链的更高层时：

1. 如果一个普通的名为 `foo` 的数据访问属性在 `[[Prototype]]` 链的高层某处被找到，**而且没有被标记为只读（writable:false）**，那么一个名为 `foo` 的新属性就直接添加到 `myObject` 上，形成一个 **遮蔽属性**。
2. 如果一个 `foo` 在 `[[Prototype]]` 链的高层某处被找到，但是它被标记为 **只读（writable:false）** ，那么设置既存属性和在 `myObject` 上创建遮蔽属性都是 **不允许** 的。如果代码运行在 `strict mode` 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，**没有发生遮蔽**。
3. 如果一个 `foo` 在 `[[Prototype]]` 链的高层某处被找到，而且它是一个 setter（见第三章），那么这个 setter 总是被调用。没有 `foo` 会被添加到（也就是遮蔽在）`myObject` 上，这个 `foo` setter 也不会被重定义。

大多数开发者认为，如果一个属性已经存在于 `[[Prototype]]` 链的高层，那么对它的赋值（`[[Put]]`）将总是造成遮蔽。但如你所见，这仅在刚才描述的三中场景中的一种（第一种）中是对的。

如果你想在第二和第三种情况中遮蔽 `foo`，那你就不能使用 `=` 赋值，而必须使用 `Object.defineProperty(..)`（见第三章）将 `foo` 添加到 `myObject`。

### （原型）继承

js的继承都是依托原型之间的链接进行的，不会像传统类那样进行拷贝，只是将原型从一个地方链到另一个地方。

这里是一段典型的创建这样的链接的“原型风格”代码：

```
function Foo(name) {
	this.name = name;
}

Foo.prototype.myName = function() {
	return this.name;
};

function Bar(name,label) {
	Foo.call( this, name );
	this.label = label;
}

// 这里，我们创建一个新的 `Bar.prototype` 链接链到 `Foo.prototype`
Bar.prototype = Object.create( Foo.prototype );

// 注意！现在 `Bar.prototype.constructor` 不存在了，
// 如果你有依赖这个属性的习惯的话，它可以被手动“修复”。

Bar.prototype.myLabel = function() {
	return this.label;
};

var a = new Bar( "a", "obj a" );

a.myName(); // "a"
a.myLabel(); // "obj a"
```

**注意：** 要想知道为什么上面代码中的 `this` 指向 `a`，参见第二章。

重要的部分是 `Bar.prototype = Object.create( Foo.prototype )`。`Object.create(..)` 凭空 *创建* 了一个“新”对象，并将这个新对象内部的 `[[Prototype]]` 链接到你指定的对象上（在这里是 `Foo.prototype`）。

换句话说，这一行的意思是：“做一个 *新的* 链接到‘Foo 点儿 prototype’的‘Bar 点儿 prototype ’对象”。

## 对象链接

正如我们看到的，`[[Prototype]]` 机制是一个内部链接，它存在于一个对象上，这个对象引用一些其他的对象。

这种链接（主要）在对一个对象进行属性/方法引用，但这样的属性/方法不存在时实施。在这种情况下，`[[Prototype]]` 链接告诉引擎在那个被链接的对象上查找这个属性/方法。接下来，如果这个对象不能满足查询，它的 `[[Prototype]]` 又会被查找，如此继续。这个在对象间的一系列链接构成了所谓的“原形链”。

### 创建链接

我们已经彻底揭露了为什么 JavaScript 的 `[[Prototype]]` 机制和 *类* **不** 一样，而且我们也看到了如何在正确的对象间创建 **链接**。

`[[Prototype]]` 机制的意义是什么？为什么总是见到 JS 开发者们费那么大力气（模拟类）在他们的代码中搞乱这些链接？

记得我们在本章很靠前的地方说过 `Object.create(..)` 是英雄吗？现在，我们准备好看看为什么了。

```
var foo = {
	something: function() {
		console.log( "Tell me something good..." );
	}
};

var bar = Object.create( foo );

bar.something(); // Tell me something good...
```

`Object.create(..)` 创建了一个链接到我们指定的对象（`foo`）上的新对象（`bar`），这给了我们 `[[Prototype]]` 机制的所有力量（委托），而且没有 `new` 函数作为类和构造器调用产生的所有没必要的复杂性，搞乱 `.prototype` 和 `.constructor` 引用，或任何其他的多余的东西。

#### 部分填补 `Object.create()`

`Object.create(..)` 在 ES5 中被加入。你可能需要支持 ES5 之前的环境（比如老版本的 IE），所以让我们来看一个 `Object.create(..)` 的简单 **部分** 填补工具，它甚至能在更老的 JS 环境中给我们所需的能力：

```
if (!Object.create) {
	Object.create = function(o) {
		function F(){}
		F.prototype = o;
		return new F();
	};
}
```

## 委托设计模式

但是现在让我们试着用 *行为委托* 代替 *类* 来思考同样的问题。

你将首先定义一个称为 `Task` 的 **对象**（不是一个类，也不是一个大多数 JS 开发者想让你相信的 `function`），而且它将拥有具体的行为，这些行为包含各种任务可以使用的（读作：*委托至*！）工具方法。然后，对于每个任务（“XYZ”，“ABC”），你定义一个 **对象** 来持有这个特定任务的数据/行为。你 **链接** 你的特定任务对象到 `Task` 工具对象，允许它们在必要的时候可以委托到它。

基本上，你认为执行任务“XYZ”就是从两个兄弟/对等的对象（`XYZ` 和 `Task`）中请求行为来完成它。与其通过类的拷贝将它们组合在一起，我们可以将它们保持在分离的对象中，而且可以在需要的情况下允许 `XYZ` 对象 **委托到** `Task`。

这里是一些简单的代码，示意你如何实现它：

```js
var Task = {
	setID: function(ID) { this.id = ID; },
	outputID: function() { console.log( this.id ); }
};

// 使 `XYZ` 委托到 `Task`
var XYZ = Object.create( Task );

XYZ.prepareTask = function(ID,Label) {
	this.setID( ID );
	this.label = Label;
};

XYZ.outputTaskDetails = function() {
	this.outputID();
	console.log( this.label );
};

// ABC = Object.create( Task );
// ABC ... = ...
```

在这段代码中，`Task` 和 `XYZ`不是类（也不是函数），它们 **仅仅是对象**。`XYZ` 通过 `Object.create()` 创建，来 `[[Prototype]]` 委托到 `Task` 对象

#### class与委托比较

```js
class Widget {
	constructor(width,height) {
		this.width = width || 50;
		this.height = height || 50;
		this.$elem = null;
	}
	render($where){
		if (this.$elem) {
			this.$elem.css( {
				width: this.width + "px",
				height: this.height + "px"
			} ).appendTo( $where );
		}
	}
}

class Button extends Widget {
	constructor(width,height,label) {
		super( width, height );
		this.label = label || "Default";
		this.$elem = $( "<button>" ).text( this.label );
	}
	render($where) {
		super.render( $where );
		this.$elem.click( this.onClick.bind( this ) );
	}
	onClick(evt) {
		console.log( "Button '" + this.label + "' clicked!" );
	}
}

$( document ).ready( function(){
	var $body = $( document.body );
	var btn1 = new Button( 125, 30, "Hello" );
	var btn2 = new Button( 150, 40, "World" );

	btn1.render( $body );
	btn2.render( $body );
} );
```

```js
var Widget = {
	init: function(width,height){
		this.width = width || 50;
		this.height = height || 50;
		this.$elem = null;
	},
	insert: function($where){
		if (this.$elem) {
			this.$elem.css( {
				width: this.width + "px",
				height: this.height + "px"
			} ).appendTo( $where );
		}
	}
};

var Button = Object.create( Widget );

Button.setup = function(width,height,label){
	// delegated call
	this.init( width, height );
	this.label = label || "Default";

	this.$elem = $( "<button>" ).text( this.label );
};
Button.build = function($where) {
	// delegated call
	this.insert( $where );
	this.$elem.click( this.onClick.bind( this ) );
};
Button.onClick = function(evt) {
	console.log( "Button '" + this.label + "' clicked!" );
};

$( document ).ready( function(){
	var $body = $( document.body );

	var btn1 = Object.create( Button );
	btn1.setup( 125, 30, "Hello" );

	var btn2 = Object.create( Button );
	btn2.setup( 150, 40, "World" );

	btn1.build( $body );
	btn2.build( $body );
} );
```

# 类型和文法

## 内建类型

JavaScript 定义了七种内建类型：

- `null`
- `undefined`
- `boolean`
- `number`
- `string`
- `object`
- `symbol` -- 在 ES6 中被加入的！

**注意：** 除了 `object` 所有这些类型都被称为“基本类型（primitives）”。

# typeof

typeof 操作在用于安全的变量检查工作中是很有用的，如下例子：

```js
// 噢，这将抛出一个错误！
if (DEBUG) {
	console.log( "Debugging is starting" );
}

// 并不是所有的全局变量都是window
if (window.DEBUG) {
	console.log( "Debugging is starting" );
}

// 这是一个安全的存在性检查
if (typeof DEBUG !== "undefined") {
	console.log( "Debugging is starting" );
}
```

# Number

在 JavaScript 中字面数字一般用十进制小数表达。例如：

```
var a = 42;
var b = 42.3;
```

小数的整数部分如果是 `0`，是可选的：

```
var a = 0.42;
var b = .42;
```

相似地，一个小数在 `.` 之后的小数部分如果是 `0`，是可选的：

```
var a = 42.0;
var b = 42.;
```

**警告：** `42.` 是极不常见的，如果你正在努力避免别人阅读你的代码时感到困惑，它可能不是一个好主意。但不管怎样，它是合法的。

`number` 字面量还可以使用其他进制表达，比如二进制，八进制，和十六进制。

这些格式是可以在当前版本的 JavaScript 中使用的：

```
0xf3; // 十六进制的: 243
0o363;		// 八进制的: 243
0b11110011;	// 二进制的: 243
```

保持使用小写的谓词 `0x`、`0b`、和`0o`。

# MAX_SAFE_INTEGER

**Number.MAX_SAFE_INTEGER** 常量表示在 JavaScript 中最大的安全整数（maxinum safe integer)（`2^53 - 1）。`

MAX_SAFE_INTEGER 是一个值为 9007199254740991的常量。因为Javascript的数字存储使用了`[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point)中规定的[双精度浮点数](https://zh.wikipedia.org/zh-cn/雙精度浮點數)数据类型，而这一数据类型能够安全存储 `-(253 - 1)` 到 `253 - 1 之间的数值（包含边界值）。

这里安全存储的意思是指能够准确区分两个不相同的值，例如 `Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 将得到 true的结果，而这在数学上是错误的`

## 值与引用

在其他许多语言中，根据你使用的语法，值可以通过值拷贝，也可以通过引用拷贝来赋予/传递。在 JavaScript 中，没有指针，并且引用的工作方式有一点儿不同。你不能拥有一个从一个 JS 变量到另一个 JS 变量的引用。这是完全不可能的。

JS 中的引用指向一个（共享的） **值**，所以如果你有十个不同的引用，它们都总是同一个共享值的不同引用；**它们没有一个是另一个的引用/指针。**

另外，在 JavaScript 中，没有语法上的提示可以控制值和引用的赋值/传递。取而代之的是，值的 *类型* 用来 *唯一* 控制值是通过值拷贝，还是引用拷贝来赋予。

简单值（也叫基本标量） *总是* 通过值拷贝来赋予/传递：`null`、`undefined`、`string`、`number`、 `boolean`、以及 ES6 的 `symbol`。

复合值 —— `object`（包括 `array`，和所有的对象包装器 —— 见第三章）和 `function` —— *总是* 在赋值或传递时创建一个引用的拷贝。

## 封箱包装器

这些对象包装器服务于一个非常重要的目的。基本类型值没有属性或方法，所以为了访问 `.length` 或 `.toString()` 你需要这个值的对象包装器。值得庆幸的是，JS 将会自动地 *封箱*（也就是包装）基本类型值来满足这样的访问。

```
var a = "abc";

a.length; // 3
a.toUpperCase(); // "ABC"
```

那么，如果你想以通常的方式访问这些字符串值上的属性/方法，比如一个 `for` 循环的 `i < a.length` 条件，这么做看起来很有道理：一开始就得到一个这个值的对象形式，于是 JS 引擎就不需要隐含地为你创建一个。

## JSON 字符串化

对于最简单的值，JSON 字符串化行为基本上和 `toString()` 转换是相同的，除了序列化的结果 *总是一个 string*：

```
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" （一个包含双引号的字符串）
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

`JSON.stringify(..)` 工具在遇到 `undefined`、`function`、和 `symbol` 时将会自动地忽略它们。如果在一个 `array` 中遇到这样的值，它会被替换为 `null`（这样数组的位置信息就不会改变）。如果在一个 `object` 的属性中遇到这样的值，这个属性会被简单地剔除掉。

考虑下面的代码：

```
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}"
```

但如果你试着 `JSON.stringify(..)` 一个带有循环引用的 `object`，就会抛出一个错误。

JSON 字符串化有一个特殊行为，如果一个 `object` 值定义了一个 `toJSON()` 方法，这个方法将会被首先调用，以取得用于序列化的值。

如果你打算 JSON 字符串化一个可能含有非法 JSON 值的对象，或者如果这个对象中正好有不适于序列化的值，那么你就应当为它定义一个 `toJSON()` 方法，返回这个 `object` 的一个 *JSON 安全* 版本。

例如：

```
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// 在 `a` 内部制造一个循环引用
o.e = a;

// 这会因循环引用而抛出一个错误
// JSON.stringify( a );

// 自定义一个 JSON 值序列化
a.toJSON = function() {
	// 序列化仅包含属性 `b`
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

`toJSON()` 应当被翻译为：“变为一个适用于字符串化的 JSON 安全的值”，而不是像许多开发者错误认为的那样，“变为一个 JSON 字符串”。

**`JSON.stringify(..)` 的第二个参数值是可选的**，它称为 *替换器（replacer）*。这个参数值既可以是一个 `array` 也可以是一个 `function`。与 `toJSON()` 为序列化准备一个值的方式类似，它提供一种过滤机制，指出一个 `object` 的哪一个属性应该或不应该被包含在序列化形式中，来自定义这个 `object` 的递归序列化行为。

如果 *替换器* 是一个 `array`，那么它应当是一个 `string` 的 `array`，它的每一个元素指定了允许被包含在这个 `object` 的序列化形式中的属性名称。如果一个属性不存在于这个列表中，那么它就会被跳过。

如果 *替换器* 是一个 `function`，那么它会为 `object` 本身而被调用一次，并且为这个 `object` 中的每个属性都被调用一次，而且每次都被传入两个参数值，*key* 和 *value*。要在序列化中跳过一个 *key*，可以返回 `undefined`。否则，就返回被提供的 *value*。

**`JSON.stringify(..)` 还可以接收第三个可选参数值**，称为 *填充符（space）*，在对人类友好的输出中它被用做缩进。*填充符*可以是一个正整数，用来指示每一级缩进中应当使用多少个空格字符。或者，*填充符* 可以是一个 `string`，这时每一级缩进将会使用它的前十个字符。